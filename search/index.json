[{"content":"题目链接：查找拥有有效邮箱的用户\nTags：高级字符串函数 / 正则表达式 / 子句\n难度：简单\n题目原文\r表: Users\n+---------------+---------+ | Column Name | Type | +---------------+---------+ | user_id | int | | name | varchar | | mail | varchar | +---------------+---------+ user_id 是该表的主键（具有唯一值的列）。 该表包含了网站已注册用户的信息。有一些电子邮件是无效的。 编写一个解决方案，以查找具有有效电子邮件的用户。\n一个有效的电子邮件具有前缀名称和域，其中：\n前缀 名称是一个字符串，可以包含字母（大写或小写），数字，下划线 '_' ，点 '.' 和（或）破折号 '-' 。前缀名称 必须 以字母开头。 域 为 '@leetcode.com' 。 以任何顺序返回结果表。\n结果的格式如以下示例所示：\n示例 1：\n输入： Users 表: +---------+-----------+-------------------------+ | user_id | name | mail | +---------+-----------+-------------------------+ | 1 | Winston | winston@leetcode.com | | 2 | Jonathan | jonathanisgreat | | 3 | Annabelle | bella-@leetcode.com | | 4 | Sally | sally.come@leetcode.com | | 5 | Marwan | quarz#2020@leetcode.com | | 6 | David | david69@gmail.com | | 7 | Shapiro | .shapo@leetcode.com | +---------+-----------+-------------------------+ 输出： +---------+-----------+-------------------------+ | user_id | name | mail | +---------+-----------+-------------------------+ | 1 | Winston | winston@leetcode.com | | 3 | Annabelle | bella-@leetcode.com | | 4 | Sally | sally.come@leetcode.com | +---------+-----------+-------------------------+ 解释： 用户 2 的电子邮件没有域。 用户 5 的电子邮件带有不允许的 \u0026#39;#\u0026#39; 符号。 用户 6 的电子邮件没有 leetcode 域。 用户 7 的电子邮件以点开头。 解答思路\r首先根据题目给出邮件正则表达式：\n前缀 名称是一个字符串，可以包含字母（大写或小写），数字，下划线 '_' ，点 '.' 和（或）破折号 '-' 。前缀名称 必须 以字母开头。 对应着 ^[a-zA-Z][\\\\w\\\\.-]*? 域 为 '@leetcode.com' 。 对应着 @leetcode\\\\.com$ 于是将两者拼接起来就是最终的语句：\n1 2 3 SELECT * FROM Users WHERE mail RLIKE \u0026#39;^[a-zA-Z][\\\\w\\\\.-]*?@leetcode\\\\.com$\u0026#39; 非常好，所以我们一键提交。。。。。等待结果中，结果当然是。。。。诶，怎么出错了，定睛一看，代码在第26个测试集运行出错。该测试集只有一个：\n| user_id | name | mail | | ------- | ------- | -------------------- | | 1 | Winston | winston@leetcode.COM | 我们可以看到，mail字段的顶级域名变为大写了，但是我们的正则表达式匹配的是小写啊，这是为什么。别急我们，首先来看看数据库使用的比较规则，你可以直接在力扣中使用：\n1 SHOW VARIABLES LIKE \u0026#39;%collation%\u0026#39; 没有意外的话，结果集应该如下：\n| Variable_name | Value | | ----------------------------- | ------------------ | | collation_connection | utf8mb4_general_ci | | collation_database | utf8mb3_general_ci | | collation_server | utf8mb4_0900_ai_ci | | default_collation_for_utf8mb4 | utf8mb4_0900_ai_ci | 对于字段 collation_database，该字段代表着数据库的比较规则，其值为 utf8mb3_general_ci，我们直接看最后面的后缀ci，这代表着数据库字段本身的比较不区分大小写。因此我们可以预见性地肯定以下查询结果为 true ：\n1 SELECT \u0026#39;COM\u0026#39; = \u0026#39;com\u0026#39; -- 结果为true 如果要让数据库比较规则大小写敏感的话，应该使用 bin 后缀。这里有两种解决办法。第一种修改比较的变量：\n1 2 3 4 SET SESSION collation_database = \u0026#39;utf8mb3_bin\u0026#39;; SELECT * FROM Users WHERE mail RLIKE \u0026#39;^[a-zA-Z][\\\\w\\\\.-]*?@leetcode\\\\.com$\u0026#39;; 但力扣只支持一次查询，因此上面的方法不可用，那么第二种，我们可以在查询的时候设定比较的规则：\n1 2 3 SELECT * FROM Users WHERE mail COLLATE utf8mb3_bin RLIKE \u0026#39;^[a-zA-Z][\\\\w\\\\.-]*?@leetcode\\\\.com$\u0026#39; 我们将比较规则设定为 utf8mb3_bin，服务器将会直接比较底层的二进制数据，大小写的二进制数据当然不一样，这样比较的时候就大小写敏感了。\n这下一运行，直接通过！\n参考\r官方题解\nLinux和Windows的大小写规范\r对于关键字来说，两个操作系统的关键字都不区分大小写。但由于两个操作系统的文件系统不一样，对大小是否敏感也不一样，导致了在 Linux 上编译的 MySQL，其数据库名、表名本身大小写敏感，而在 Windows 上编译的则大小写不敏感，因为总所周知，数据库反映在文件系统上就是一个目录，数据库名就是目录名，表则是一个文件，表名则是文件名。在 Mysql 中使用 lower_case_table_names 来控制表名的大小写是否敏感，其取值如下：\n值 含义 适用场景 0 区分大小写（Linux 默认） 表名 MyTable和 mytable不同 1 存储为小写，不区分大小写（Windows 默认） 所有表名转为小写存储，查询时不区分大小写 2 存储保留大小写，但查询不区分（混合模式 ） 表名按创建时的格式存储，但查询时忽略大小写 Linux 中默认为0，Windows 默认为1\n对于字段名来说，因为默认的匹配规则不区分大小写，因此在两个操作系统上列名默认来说大小写不敏感。因此，最好遵守以下规范：\n关键词全部大写 对于表名、数据库名以及字段名，全部人为区分大小写，但最好设计为小写。例如表名为 Users，查询时也应该使用 Users ","date":"2025-08-05T12:38:31+08:00","permalink":"http://localhost:1313/post/2025/08/sql%E5%9F%BA%E7%A1%80-50/","title":"50-查找拥有有效邮箱的用户"},{"content":"题目链接：按分类统计薪水\nTags：高级查询和连接\n难度：中等\n题目原文\r表: Accounts\n+-------------+------+ | 列名 | 类型 | +-------------+------+ | account_id | int | | income | int | +-------------+------+ 在 SQL 中，account_id 是这个表的主键。 每一行都包含一个银行帐户的月收入的信息。 查询每个工资类别的银行账户数量。 工资类别如下：\n\u0026quot;Low Salary\u0026quot;：所有工资 严格低于 20000 美元。 \u0026quot;Average Salary\u0026quot;： 包含 范围内的所有工资 [$20000, $50000] 。 \u0026quot;High Salary\u0026quot;：所有工资 严格大于 50000 美元。 结果表 必须 包含所有三个类别。 如果某个类别中没有帐户，则报告 0 。\n按 任意顺序 返回结果表。\n查询结果格式如下示例。\n示例 1：\n输入： Accounts 表: +------------+--------+ | account_id | income | +------------+--------+ | 3 | 108939 | | 2 | 12747 | | 8 | 87709 | | 6 | 91796 | +------------+--------+ 输出： +----------------+----------------+ | category | accounts_count | +----------------+----------------+ | Low Salary | 1 | | Average Salary | 0 | | High Salary | 3 | +----------------+----------------+ 解释： 低薪: 有一个账户 2. 中等薪水: 没有. 高薪: 有三个账户，他们是 3, 6和 8. 解答思路\r该题其实不难，现在我提供一个我的错误解法供大家批判：\n1 2 3 4 5 6 7 8 9 SELECT category, COUNT(1) accounts_count FROM ( SELECT account_id, CASE WHEN income \u0026lt; 20000 THEN \u0026#39;Low Salary\u0026#39; WHEN income \u0026lt;= 50000 THEN \u0026#39;Average Salary\u0026#39; ELSE \u0026#39;Average Salary\u0026#39; END \u0026#34;category\u0026#34; FROM Accounts ) t GROUP BY category 这种解法其实没有问题，只不过不符合题意。当没有一个种类出现在表中时，就无法显示该种类，题目中的例子说明了恰恰应该显示该种类，且数量为0。\n当我看到官方解法是，突然茅塞顿开，显然我忘记了一个很重要的关键字 UNION ，下面我们贴出官方解法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 SELECT \u0026#39;Low Salary\u0026#39; AS category, SUM(CASE WHEN income \u0026lt; 20000 THEN 1 ELSE 0 END) AS accounts_count FROM Accounts UNION SELECT \u0026#39;Average Salary\u0026#39; category, SUM(CASE WHEN income \u0026gt;= 20000 AND income \u0026lt;= 50000 THEN 1 ELSE 0 END) AS accounts_count FROM Accounts UNION SELECT \u0026#39;High Salary\u0026#39; category, SUM(CASE WHEN income \u0026gt; 50000 THEN 1 ELSE 0 END) AS accounts_count FROM Accounts 官方解法使用 UNION 拼接了三组查询，就不会出现上述我的解法的那种情况，但官方解法仍有改进空间，下面我来进行改进：\n1 2 3 4 5 6 7 8 9 10 11 SELECT \u0026#39;Low Salary\u0026#39; AS category,COUNT(1) accounts_count FROM Accounts WHERE income \u0026lt; 20000 UNION ALL SELECT \u0026#39;Average Salary\u0026#39; category, COUNT(1) accounts_count FROM Accounts WHERE income BETWEEN 20000 AND 50000 UNION ALL SELECT \u0026#39;High Salary\u0026#39; category, COUNT(1) accounts_count FROM Accounts WHERE income \u0026gt; 50000 UNION ALL 相比 UNION 来说更快一点，因为 UNION 要去重，而 UNION ALL 会直接拼接不会进行去重，对于无重复的数据来说，UNION ALL 会更合适点；然后我们将 CASE 表达式换成了 WHERE ，且将 SUM() 换成了 COUNT() ，这增加了了代码的可读性。\n重要\r在使用 UNION 或者 UNION ALL 拼接时，要注意下面的情况：\n字段的个数一定要相同 字段名可以不同，但类型必须相同，结果集以第一个查询的字段为结果集的字段 ORDER BY 和 LIMIT 只能放在最后一个查询的末尾进行全部结果集的结果控制。若要在每个查询中使用，则需将查询用括号括起来当作子查询。 ","date":"2025-07-30T11:17:46+08:00","permalink":"http://localhost:1313/post/2025/07/sql%E5%9F%BA%E7%A1%80-35/","title":"35-按分类统计薪水"},{"content":"题目链接：最后一个能进入巴士的人 Tags：高级查询和连接 难度：中等\n题目原文\r表: Queue\n+-------------+---------+ | Column Name | Type | +-------------+---------+ | person_id | int | | person_name | varchar | | weight | int | | turn | int | +-------------+---------+ person_id 是这个表具有唯一值的列。 该表展示了所有候车乘客的信息。 表中 person_id 和 turn 列将包含从 1 到 n 的所有数字，其中 n 是表中的行数。 turn 决定了候车乘客上巴士的顺序，其中 turn=1 表示第一个上巴士，turn=n 表示最后一个上巴士。 weight 表示候车乘客的体重，以千克为单位。 有一队乘客在等着上巴士。然而，巴士有1000 千克 的重量限制，所以其中一部分乘客可能无法上巴士。\n编写解决方案找出 最后一个 上巴士且不超过重量限制的乘客，并报告 person_name 。题目测试用例确保顺位第一的人可以上巴士且不会超重。\n返回结果格式如下所示。\n示例 1：\n输入： Queue 表 +-----------+-------------+--------+------+ | person_id | person_name | weight | turn | +-----------+-------------+--------+------+ | 5 | Alice | 250 | 1 | | 4 | Bob | 175 | 5 | | 3 | Alex | 350 | 2 | | 6 | John Cena | 400 | 3 | | 1 | Winston | 500 | 6 | | 2 | Marie | 200 | 4 | +-----------+-------------+--------+------+ 输出： +-------------+ | person_name | +-------------+ | John Cena | +-------------+ 解释： 为了简化，Queue 表按 turn 列由小到大排序。 +------+----+-----------+--------+--------------+ | Turn | ID | Name | Weight | Total Weight | +------+----+-----------+--------+--------------+ | 1 | 5 | Alice | 250 | 250 | | 2 | 3 | Alex | 350 | 600 | | 3 | 6 | John Cena | 400 | 1000 | (最后一个上巴士) | 4 | 2 | Marie | 200 | 1200 | (无法上巴士) | 5 | 4 | Bob | 175 | ___ | | 6 | 1 | Winston | 500 | ___ | +------+----+-----------+--------+--------------+ 解答思路\r解法一\r我的解法很直观，求出当前趟数上车后的总重量之后，与1000进行比较就能得出最后一趟能够上车的人了。我们先进行第一步，求出对应趟数的总重量：\n1 2 3 SELECT person_name, (SELECT SUM(weight) FROM Queue WHERE q.turn \u0026gt;= turn) cur_weight FROM Queue q ORDER BY turn ASC 在这里我是用了关联子查询，计算出当趟的总重量。\n之后将这个当作一个新表，将最后一个能上车的人过滤出来，代码如下：\n1 2 3 4 5 6 7 8 9 SELECT person_name FROM ( SELECT person_name, (SELECT SUM(weight) FROM Queue WHERE q.turn \u0026gt;= turn) cur_weight FROM Queue q ORDER BY turn ASC ) t WHERE cur_weight \u0026lt;= 1000 ORDER BY cur_weight DESC LIMIT 1 代码很直观，就是按照 cur_weight 排序将最后一位置于第一个，分页即可。但这里，我得批评自己，想了一会儿才想到 使用 ORDER BY 和 LIMIT，这些用的少的关键字还是得牢牢记在心里。\n重要\r使用关联子查询时，每当服务器扫描表中的一行时都会执行该子查询，由此可见，该解法其实其速度会巨慢无比，时间复杂度来到了O(n^2)\n但如果关联子查询能替换为自连接的话，时间复杂度同样为O(n^2)，但速度会快不少，因为服务器会对自连接有优化。\n官方解法\r官方解法就是用了自连接给出的答案，下面我们直接贴出来：\n1 2 3 4 5 6 7 SELECT a.person_name FROM Queue a, Queue b WHERE a.turn \u0026gt;= b.turn GROUP BY a.person_id HAVING SUM(b.weight) \u0026lt;= 1000 ORDER BY a.turn DESC LIMIT 1 官方解法将我的关联子查询替换为了自连接，除了这块其实两者没什么区别。我们将子表a理解为当趟，子表b理解为前趟，这里注意连接条件，将当趟比前趟趟数大的筛选出来，随后按趟数分组进行统计，最后排序取第一个即可。\n建议\r这里在设计自连接的连接条件时，其实连接的表我们都可以如上述当趟和前趟的理解。比如职员表 Employee ，自连接时前者可以理解为员工，后者可以理解为上司。\n参考\r官方解法\n","date":"2025-07-30T11:17:43+08:00","permalink":"http://localhost:1313/post/2025/07/sql%E5%9F%BA%E7%A1%80-34/","title":"34-最后一个能进入巴士的人"},{"content":"题目链接：指定日期的产品价格 Tags：高级查询和连接 难度：中等\n题目原文\r产品数据表: Products\n+---------------+---------+ | Column Name | Type | +---------------+---------+ | product_id | int | | new_price | int | | change_date | date | +---------------+---------+ (product_id, change_date) 是此表的主键（具有唯一值的列组合）。 这张表的每一行分别记录了 某产品 在某个日期 更改后 的新价格。 一开始，所有产品价格都为 10。\n编写一个解决方案，找出在 2019-08-16 所有产品的价格。\n以 任意顺序 返回结果表。\n结果格式如下例所示。\n示例 1:\n输入： Products 表: +------------+-----------+-------------+ | product_id | new_price | change_date | +------------+-----------+-------------+ | 1 | 20 | 2019-08-14 | | 2 | 50 | 2019-08-14 | | 1 | 30 | 2019-08-15 | | 1 | 35 | 2019-08-16 | | 2 | 65 | 2019-08-17 | | 3 | 20 | 2019-08-18 | +------------+-----------+-------------+ 输出： +------------+-------+ | product_id | price | +------------+-------+ | 2 | 50 | | 1 | 35 | | 3 | 10 | +------------+-------+ 解答思路\r解法一\r我的思路很简单，题目原文所描述的情况如下所示：\n若商品未在 2019-08-16 之前就改价，则其价格未默认10块 若改价，则以最靠近 2019-08-16 的价格未最终价格 因此，我们首先应该求得商品改价的最终日期，代码如下：\n1 2 3 SELECT product_id, MAX(IF(change_date \u0026lt;= \u0026#39;2019-08-16\u0026#39;,change_date, NULL)) max_date FROM Products GROUP BY product_id 使用 MAX() 函数求得最靠近 2019-08-16 的日期，若雀氏没有，则该字段为 NULL 。随后，需与原表连接求得对应日期的价格，这就是最后的代码：\n1 2 3 4 5 6 7 SELECT DISTINCT p.product_id, IF(t.max_date IS NULL, 10, new_price) price FROM Products p JOIN ( SELECT product_id, MAX(IF(change_date \u0026lt;= \u0026#39;2019-08-16\u0026#39;,change_date, NULL)) max_date FROM Products GROUP BY product_id ) t ON p.product_id = t.product_id AND (p.change_date = t.max_date OR t.max_date IS NULL) 需要注意的是连接条件的设置，要求保证商品id相同，且变更日期与 max_date 一致，或者 max_date 为空。后面两个条件需要用括号括起来，因为 AND 的优先级要大于 OR，所以没有使用括号则连接条件会变成如下所示：\n1 (p.product_id = t.product_id AND p.change_date = t.max_date) OR t.max_date IS NULL 最后的结果会整整多出来n - 1行，n 是 Products 表的行数。\nDISTINCT 会保证最后的结果唯一，因为 max_date 为空的商品可能会在 2019-08-16 之后改变多次。\n官方解法\r我们直接贴出代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 select p1.product_id, ifnull(p2.new_price, 10) as price from ( select distinct product_id from products ) as p1 -- 所有的产品 left join ( select product_id, new_price from products where (product_id, change_date) in ( select product_id, max(change_date) from products where change_date \u0026lt;= \u0026#39;2019-08-16\u0026#39; group by product_id ) ) as p2 -- 在 2019-08-16 之前有过修改的产品和最新的价格 on p1.product_id = p2.product_id 官方的解法和我的解法差不太多，在这里贴出来，提醒一下自己一个很少用的语法，对于多字段的子查询过滤条件可以使用如上的语法。\n参考\r解法一\n官方解法\n","date":"2025-07-30T11:15:58+08:00","permalink":"http://localhost:1313/post/2025/07/sql%E5%9F%BA%E7%A1%80-33/","title":"33-指定日期的产品价格"},{"content":"题目链接：连续出现的数字 Tags: 高级查询和连接\n难度：中等\n题目原文\r表：Logs\n+-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | num | varchar | +-------------+---------+ 在 SQL 中，id 是该表的主键。 id 是一个自增列。 找出所有至少连续出现三次的数字。\n返回的结果表中的数据可以按 任意顺序 排列。\n结果格式如下面的例子所示：\n示例 1:\n输入： Logs 表： +----+-----+ | id | num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ 输出： Result 表： +-----------------+ | ConsecutiveNums | +-----------------+ | 1 | +-----------------+ 解释：1 是唯一连续出现至少三次的数字。 解答思路\r解法一\r本题需要使用到 窗口函数：\nrow_number() over([partition by value_expression,...n] order by columnName)\n在做题之前需要明白这样一个结论，对于一个连续出现的数，其下标与出现次数的差为一个定值，这个结论很关键。下面我们来推导一下这个结论。\n假设当前数字的下标为i，这是他在连续数字序列中的第k次出现。那么他们的差为i-k。\n当数字从当前下标开始连续出现了m次时，其下标为i+m，则该数字已经出现了k+m次，他们的差为i-k。\n而当一个数字的下标为i，同时他在连续数字序列中的第k次出现，隔了m个不连续的数字，此时的下表为i+m，但出现的次数是k+1，则差为i+m-k-1。与之前连续的数字的差值不一样，则该数字与前面的连续数字并不连续。\n因此基于这个理论，我们首先要计算其出现的次数，这就要用到如上的窗口函数了：\n1 2 SELECT *, ROW_NUMBER() OVER(PARTITION BY num ORDER BY id) cur_count FROM Logs 运行结果可以参考如下所示：\n1 2 3 4 5 6 7 8 9 | id | num | cur_count | | -- | --- | --------- | | 1 | 1 | 1 | | 2 | 1 | 2 | | 3 | 1 | 3 | | 5 | 1 | 4 | | 4 | 2 | 1 | | 6 | 2 | 2 | | 7 | 2 | 3 | 其中 cur_count 字段就是该数字出现的次数。该窗口函数的作用是通过 num 分组，并按照 id 排序，此 id 就是数字的下标，ROW_NUMBER() 就是给这些分组的数加上每个组里的下标，也就是次数。根据结果发现，上述结论确实是正确的。所有，接下来我们就要算出两者的差，只需要对上述语句进行一点改造：\n1 2 SELECT num, id - ROW_NUMBER() OVER(PARTITION BY num ORDER BY id) sub_num #我们只需要这两组值，减少字段有助于增加效率 FROM Logs 将上述查询当作子查询充当表，写出最终的查询语句：\n1 2 3 4 5 6 SELECT DISTINCT num ConsecutiveNums FROM ( SELECT num, id - ROW_NUMBER() OVER(PARTITION BY num ORDER BY id) sub_num FROM Logs ) t GROUP BY num, sub_num HAVING COUNT(1) \u0026gt;= 3 首先我们根据 num 和 sub_num 进行分组，因为连续的数字 sub_num 才会相同，过滤每个组的数量小于3的组，即可。最后对结果去重，是因为一个连续的数字，后面还可能继续出现该连续的数字且 sub_num 不同，因此结果集可能会包括多个相同的数字，这显然不是我们想要的，因此我们需要去重。\n建议\r该结论可以当作求该连续数字的一般结论即解法，非常的优雅以及深刻\n解法二\r该解法带点取巧的特性在里面，可以稍微看一下，我们直接贴上代码：\n1 2 3 4 5 6 7 8 9 SELECT DISTINCT a.num AS ConsecutiveNums FROM ( SELECT *, LEAD(num,1) OVER() AS next1_num, LEAD(num,2) OVER() AS next2_num FROM Logs )AS a WHERE a.num = a.next1_num AND a.num = a.next2_num; 该解法非常直观，就是取到该数字前1个和前两个的数字，随后做比较，如果三者相同则代表该数字连续，则选中并去掉重复的。\n该解法与官方解法如初一辙，由于题目中的对于连续数字的判定条件——连续三个数字的范围太小，因此这样做可以做出来，但如果要求连续的数字有100个呢？因此这种解法是对于题目的取巧。\n参考\r解法一\n解法二\n官方解法\n","date":"2025-07-28T20:55:26+08:00","permalink":"http://localhost:1313/post/2025/07/sql%E5%9F%BA%E7%A1%80-32/","title":"32-连续出现的数字"},{"content":"题目链接：员工的直属部门 Tags: 高级查询和连接\n难度：简单\n题目原文\r表：Employee\n1 2 3 4 5 6 7 8 9 10 11 +---------------+---------+ | Column Name | Type | +---------------+---------+ | employee_id | int | | department_id | int | | primary_flag | varchar | +---------------+---------+ 这张表的主键为 employee_id, department_id (具有唯一值的列的组合) employee_id 是员工的ID department_id 是部门的ID，表示员工与该部门有关系 primary_flag 是一个枚举类型，值分别为(\u0026#39;Y\u0026#39;, \u0026#39;N\u0026#39;). 如果值为\u0026#39;Y\u0026#39;,表示该部门是员工的直属部门。 如果值是\u0026#39;N\u0026#39;,则否 一个员工可以属于多个部门。当一个员工加入超过一个部门的时候，他需要决定哪个部门是他的直属部门。请注意，当员工只加入一个部门的时候，那这个部门将默认为他的直属部门，虽然表记录的值为'N'.\n请编写解决方案，查出员工所属的直属部门。\n返回结果 没有顺序要求 。\n返回结果格式如下例子所示：\n示例 1：\n输入： Employee table: +-------------+---------------+--------------+ | employee_id | department_id | primary_flag | +-------------+---------------+--------------+ | 1 | 1 | N | | 2 | 1 | Y | | 2 | 2 | N | | 3 | 3 | N | | 4 | 2 | N | | 4 | 3 | Y | | 4 | 4 | N | +-------------+---------------+--------------+ 输出： +-------------+---------------+ | employee_id | department_id | +-------------+---------------+ | 1 | 1 | | 2 | 1 | | 3 | 3 | | 4 | 3 | +-------------+---------------+ 解释： - 员工 1 的直属部门是 1 - 员工 2 的直属部门是 1 - 员工 3 的直属部门是 3 - 员工 4 的直属部门是 3 解答思路\r由题目叙述可以很快地给出查询语句的大体框架,通过 employee_id 进行分组，可以分组得到每个员工对应的部门：\n1 2 3 SELECT employee_id FROM Employee GROUP BY employee_id 于是现在的首要目标就变成了：从分组的部门中，找出员工的直属部门。由题目知，直属部门满足如下两个条件之一即可：\n员工加入的部门有且只有一个 员工加入的部门中，primary_flag 被标记为 Y 通过聚合函数 COUNT() 我们可以计算出员工加入的部门的数量，如果数量为1，则返回这个部门，否则就返回 primary_flag 被标记为 Y 的部门，因此理所应当使用单行函数 IF()\n1 2 3 4 5 6 SELECT employee_id, IF(COUNT(1) = 1, /*返回这一行的department_id*/, /*否则返回primary_flag被标记为Y的department_id*/ ) AS \u0026#34;department_id\u0026#34; FROM Employee GROUP BY employee_id 那么问题来了，一旦使用了 GROUP BY 那么，字段中就不能出现 GROUP BY 中没有出现的字段，如果要出现，则需使用聚合函数，因此本题的关键就在这里，下面我们给出最终的实现：\n1 2 3 4 5 6 SELECT employee_id, IF(COUNT(1) = 1, MAX(department_id), MAX(IF(primary_flag = \u0026#39;Y\u0026#39;, department_id, null)) ) AS \u0026#34;department_id\u0026#34; FROM Employee GROUP BY employee_id 关键就是使用 MAX() 聚合函数。当行数只有一个时，则 MAX(department_id) 刚好会返回这一行的 department_id；而员工加入的直属部门只可能有一个，则 MAX(IF(primary_flag = 'Y', department_id, null)) 返回的也是该直属部门的 department_id，因为聚合函数遇到 null 会跳过。\n参考\r题解\n","date":"2025-07-25T17:46:46+08:00","permalink":"http://localhost:1313/post/2025/07/sql%E5%9F%BA%E7%A1%80-31/","title":"31-员工的直属部门"},{"content":"什么是继承\r想象一下对于Secretary类和Manager类，两者共同有相同的字段，比如姓名、职位、工资等等，但Manager类除了工资外还可能有奖金等字段。当我们实现两个类的时候，会声明两份同样的字段和方法，这未免显得太冗余了。因此，我们可以把两个类相同的字段和方法提出来放入另外一个类中，两个类只需要声明他们所需要的字段和方法就好了，其余相同的字段我们只需要从另外一个类中拿取下来就好了，这大大减少了代码的冗余。对于拿取，我们其实可以换一个词，那就是继承，这个词很形象，现实中儿子可以继承父亲的财产，儿子就相当于拥有了父亲的东西。在Java 中，儿子我们称之为子类或者派生类，父亲称之为父类、超类或者基类。\n比如我们可以让Secretary类和Manager类继承Employee类，这样Manager类和Secretary类可以直接使用Employee类的字段和方法。\n在 Java 中，使用 extends 关键字进行继承，我们以Manager类和Employee类举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class Employee { private String name; private double salary; private LocalDate hireDay; //省略构造方法和getter、setter方法 public void raiseSalary(double byPercent) { double raise = salary * byPercent / 100; salary += raise; } } public class Manager extends Employee { //Manager自身的奖金字段 private double bonus; //省略构造方法和getter、setter方法 //Manager自身的方法 public void setBonus(double b) { bonus = b; } } public class Test{ public static void main(String[] args){ Manager m = new Manger(....); m.raiseSalary(...); //Manager并没有声明这个方法，但是Manager从Employee中继承下来了，可以直接访问 //..... } } 注意\r注意，上述说明并没有提到继承的方法和字段的修饰符和访问权限，这点将在下方进行说明\n什么时候使用继承\r当类的关系满足\u0026quot;is-a\u0026quot;关系，即类b就是类a的关系，而且可以被抽取相同的字段或者方法出来时，即可使用继承。例如Manager类和Employee类，经理本身就是员工且Manager类和Employee类有相同的字段和方法，因此可以使用继承。\n继承的层次结构\rJava 中只允许类的单个继承，即一个类只能继承另一个类，但允许一个类被多个类继承，从而形成从上往下的层次结构，例如下图所示：\n%%{init: {\u0026#39;themeVariables\u0026#39;: {\u0026#39;primaryColor\u0026#39;: \u0026#39;#fff\u0026#39;}, \u0026#39;themeConfig\u0026#39;: {\u0026#39;nodeTextMargin\u0026#39;: 4}}}%%\rclassDiagram\rclass Employee\rclass Manager\rclass Secretary\rclass Programmer\rclass Executive\rEmployee \u0026lt;|-- Manager\rEmployee \u0026lt;|-- Secretary\rEmployee \u0026lt;|-- Programmer\rManager \u0026lt;|-- Executive\r任何类都能被继承，包括继承于其他类的类。Java 模糊了父类的概念，对于“祖父类”、“组祖父类”等比本类层级更高的类会被统称为父类，直接继承的称为直接父类，间接继承的称为间接父类，因此任何类都能够继承“祖父类”、“组祖父类”等父类的字段和方法。例如上图中的Executive类能够使用Manager类和Employee类的字段和方法。\n注意\r当类被final关键字修饰时，其本身不允许被继承。\n继承会继承什么\r子类并不会继承父类所有的东西，下面我们先给出结论：\n构造函数无法被继承 父类的所有成员变量都可以被继承，包括私有和非私有 父类的虚方法可以被继承 下面我们来对上述结论进行一一解释\n构造函数\r构造函数是最不可能被继承的一个方法。我们可以使用反证法来证明，若构造函数可以被继承，则子类可以使用此构造函数创建对象。这样以来就违反了构造函数的特征——方法名需要与类名相同。因此该命题出错，那么显然只能是条件就出错了。因此，父类的构造函数不能够被继承。\n重要\r构造函数的两大特征：\n没有返回值 方法名需要与类名相同 访问特点\r虽然父类的构造方法无法继承，但是却能够访问。我们仍然以Employee类和Manager类为例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Employee { private String name; private double salary; //省略构造方法和其他方法 } public class Manager extends Employee { //Manager自身的奖金字段 private double bonus; public Manager(String name, double salary, double bonus){ //第一行指代码的第一行，像这行的注释不算在其中 super(name,salary); //在构造函数第一行使用super(...)可以调用父类的构造方法， //super() //也可以调用空参构造方法，前提是父类中存在 this.bonus = bonus; } //省略其他方法方法 } 注意\r在构造自己之前，必须首先构造父类，因此构造方法中第一行必须使用关键字 super 调用父类的构造方法，若第一行缺省，虚拟机则会默认使用 super() 调用父类的空参构造。这意味着this(...) 和 super(...) 是冲突的，两者无法同时使用。同时，若缺省构造方法，虚拟机自动添加的构造方法也会默认使用 super() 调用父类的空参构造。\n成员变量\r在介绍之前，有必要先简要介绍一下虚拟机的内存分布：\n栈空间：用于存放执行的方法的空间。\n当方法执行时，会将方法入栈，期间所有的局部变量都会在该空间内分配。 当方法执行完成之后，方法就会出栈，同时方法中声明的局部变量的空间将会被释放。 堆空间：用于存放对象的空间。\n当使用new关键字创建对象时，会在堆空间开辟一个存储对象的连续空间，随后对对象的字段进行初始化。并将该空间的地址返回给引用这个对象的变量。 方法区：用于存放字节码文件。\n当第一次使用到某个类时，该类的字节码文件会被加载到该区域中。 JDK8 以后该区域变成了元空间，但我们不去讨论这些，仅仅做一些如上的简要介绍。 经过上面的介绍，我们现在可以对成员变量的继承进行一个总述了：\n当对某一个对象进行创建时，会在堆空间开辟一个区域存放该对象，由于子类可以继承父类的所有成员变量，因此会从类继承的层次结构的顶层开始，依次对类的成员变量进行初始化，直到本类的字段初始化完成，最终形成了一个对象。对于非私有的变量，允许访问，但对于私有的变量，则无法进行访问，尽管其仍被分配了空间。\n对象到底存了什么\r不是代码，也不是方法：对象本身不存储它所属类的代码（方法）——代码存在别的地方（方法区/元空间）。 核心是“状态数据”：这块连续内存里存放的最主要、最核心的东西，就是这个对象当前的状态，也就是它的所有成员变量的值。 包括“祖传家当”：这些家当不仅仅是你在这个对象自己的类里定义的变量，还包括它从祖宗十八代（继承链上的所有父类）那里继承下来的所有非静态成员变量，包括私有和非私有成员变量。从最顶级的祖先 java.lang.Object 开始，到它的直接父类、间接父类，一直到它自己这一代定义的变量，一个都不会少。 重要\r对于没有继承任何类的类，虚拟机最终会让他继承 java.lang.Object 类，所有类都派生于 java.lang.Object 类，java.lang.Object 类是所有类的父类。\n对象的空间是如何分配的\r尽管内存空间是连续分配的，但每个继承链上的类都占有自己的逻辑分区。每个分区上的成员变量互不干扰。\nObject分区：属于 java.lang.Object。这里存放Object类内置的一些必要信息（对象头，包含类信息指针、GC标记、锁状态等，虽然你看不到，但很重要），以及Object类可能定义的非静态成员变量（很少）。 父类A的分区：在Object分区之后，分配直接继承于它的子类的分区。这块区域存放父类A自己定义的所有非静态成员变量。 父类B分区 (如果有)：如果父类A还有子类（父类B），那么在父类A分区，再分配父类B，存放父类B的成员变量。以此类推，从继承链自上往下依次分配。 本类分区：最后，在所有分区的最后面，分配属于这个对象自己所属类的分区。这块区域存放你自己在这个类里定义的所有非静态成员变量。 危险\r上面叙述的分区，只是逻辑上的，并没有真实存在于物理内存中，只是为了让你理解堆空间的情况。实际上在堆空间中，从顶层的Object类开始沿着继承链向下，依次连续放置着每个类自己的的成员变量，中间没有任何象征着分区结束的标志或者空隙。而实际上，在最后会分配一个连续的内存空间，该空间没有意义，仅仅为了保证对象所占用的空间是8的倍数。\n成员变量如何初始化的\r由这一节的叙述可知，在构造本对象时，首先会构造父类的对象。因此我们可以很清楚地得出一个结论，成员变量会如下进行初始化：\n首先从Object类开始进行成员变量的初始化，随后从上往下沿着继承链，对每个类的成员变量进行初始化，直到本类。\n访问特点\r可以有三种使用方法对对象的成员变量进行访问，仍然以Employee类与Manager类为例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Employee { //注意这里没有使用private，因为私有变量无法从子类中访问，但使用public破坏了封装性 public String name; public double salary; //省略构造方法和其他方法 } public class Manager extends Employee { //Manager自身的奖金字段 private double bonus; //省略构造方法 public double getSalary(){ //第一种：相当于第二种，这种方式会受到局部变量的阴影 //对于没有同名局部变量的成员变量来说，这种方式为Java的语法糖，省略了前面的this，编译器将在前方自动加上this，即对象.成员变量的调用方式 return salary + bonus; //第二种：会直接从从本类的成员变量开始，沿着继承链向上寻找 return this.salary + bonus; //第三种：使用super关键字直接说明从父类的成员变量开始寻找 return super.salary + bonus; } } 注意\rthis 指向调用方法的隐参，相当于指向自身对象，其本身相当于是一个成员方法里的局部变量，由虚拟机自动赋值。值得注意的是，静态方法无法使用 this\nsuper 是一个关键字，没有指向任何对象，其作用只是指示编译器去父类中寻找成员变量\n成员方法\r我们把没有被final、static、private修饰的方法成为虚方法。只有虚方法才能被继承。\n重要\r实际上，被final修饰的方法也会进入虚方法表，并被继承，但本身不允许重写\n理解方法调用\r所有类的成员方法并不会存储到堆空间中，而是存放在方法区中，以字节码的形式存储。每个类的字节码文件会存放着该类的虚方法表，该表记录着所有可以被继承的方法，即虚方法。当使用一个类时，其字节码会被加载到方法区中，同时会沿着继承链把其父类的字节码文件加载进方法区中，这个过程会一直到最顶层的Object类，父类总是先于子类被放入方法区。当类被加载后，虚拟机会为该类计算出一份虚方法表，父类的虚方法表会移交给子类，子类会基于父类的虚方法表并添加上自己的虚方法生成一份自己的，并移交给自己的子类。这样，处于继承层次结构底层的类就会有一份包含父类的虚方法以及自己的虚方法的虚方法表。\n动态绑定\r当程序运行时才知道调用的具体方法。当使用形如 obj.xxx() 调用一个虚方法时，虚拟机就会去访问这个类型的方法表，例如第一节中给的例子，第29行中调用的 m.raiseSalary() 方法，虚拟机准确的找到了调用者的类型为Manager，于是去访问他的虚方法表，Manager类型继承了Employee类型的虚方法表，里面就有 raiseSalary() 方法，因此可以访问。这个过程称为动态绑定\n静态绑定\r对于非虚方法以及构造方法，虚拟机准确的知道该调用具体的方法，会在编译时就准确的绑定了，不会在运行时绑定，这个过程成为静态绑定。\n警告\r长久以来的一个误解，对于一个方法，虚拟机会依次沿着继承链向上寻找这个方法。这个过程其实是错误的，或者是片面的，因为只有构造方法才会沿着继承链向上依次调用构造方法。\n方法重写\r子类可以对成员方法进行重写，即重写一份自己的方法实现，但这仍然需要满足一定的要求，要求如下：\n方法签名必须一致。方法签名包括：方法名以及形参类型列表。\n成员变量必须是可以继承的，即如上所述的虚方法\n重写的方法的访问权限不小于父类的方法。访问权限的范围满足：public \u0026gt; protected \u0026gt; 缺省 \u0026gt; private\n返回类型的范围小于等于父类的方法。\n重写相当于改写了自己的方法表，这会对本类中的方法表中的被重写的方法进行替换。\n建议\r建议对重写的方法加上 @Override 注解，这会提醒虚拟机这是一个重写的方法，从而检查语法是否出错。\n注意\r上述第四点的返回类型的范围为广义上的范围，即表示的范围。比如，子类表示的事物比父类更具体，因此父类所表示的范围大于子类，就像Employee类能表示广大职工，而Manager类只能表示经理。\n访问特点\r仍然可以使用三种方式访问对象的成员方法，仍然以Employee类与Manager类为例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Employee { //注意这里没有使用private，因为私有变量无法从子类中访问，但使用public破坏了封装性 public String name; public double salary; public double getSalary(){ return salary } } public class Manager extends Employee { //Manager自身的奖金字段 private double bonus; //省略构造方法 public double getSalary(){ //第一种：这种会去访问本类的方法表进行查找。但这种情况下是错误的，因为我们重写了getSalary()，其替换了方法表中的父类的成员方法吗，因此这种会无限的调用自生，直至栈溢出程序停止。 return this.getSalary() + bonus; //第二种：这种相当于this.getSlary() //同样也是一种语法糖，省略了前方的this，编译器将在前方自动加上this，即对象.成员方法的调用方式 return getSalary() + bonus; //第三种：使用super指示虚拟机从父类的方法表中进行寻找。 return super.getSalary() + bonus; } } 注意\r还记得上面叙述的动态绑定和静态绑定吗，实际上只针对虚方法，因为非虚方法，早已在编译阶段就已经确定了调用的方法。\nthis 和 super 的功能汇总\rthis ：真真切切的局部变量，指向调用者自身。即调用对象的引用\nsuper ：是一个关键字，指示编译器去访问父类的成员。\n关键字 访问成员变量 访问成员方法 访问构造犯法 this this.成员变量\n访问该类成员变量 this.成员方法\n访问该类成员方法 this(\u0026hellip;)\n访问该类的构造函数 super super.成员变量\n访问父类的成员变量 super.成员方法\n访问父类的成员方法 super(\u0026hellip;)\n访问父类的构造函数 重要\r使用 super 调用父类的成员方法，其绑定方式为静态绑定。\n多态\r多态即为多种状态，这是面向对象三种特征的其一。父类在运行时不仅能表现为当前类的状态，还能表示子类的状态，即子类的对象可以赋值给父类进行引用，我们仍然使用Employee类和Manager类举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Employee { private String name; private double salary; //这里省略其他方法和字段 public void raiseSalary(double byPercent) { double raise = salary * byPercent / 100; salary += raise; } public void main(String[] args){ Employee e = new Manager(...); e.raiseSalary(...); //不会报错，成功执行 e.setBonus(...); //报错了 } } class Manager extends Employee { private double bonus; public void setBonus(double b) { bonus = b; } //这里省略其他方法和字段 } 注意\r值得注意的是，is a 原则描述的是一个替换原则，当两个类型满足 is a 原则时就能使用多态。比如 Manager[] 他是 Employee[] ，因此 Emplpoyee[] array = new Manager[]{} 是合法的\n成员方法的访问\r对于虚方法，编译期间会查看对象类型的成员方法是否存在或者能否访问；运行期间会查找实际类型的方法表，进而访问实际类型的具体方法。 对于非虚方法来说，其将会忽略多态，直接调用对象类型的方法。\n注意\r值得注意的是，对象的类型是其声明的类型，实际类型是真实的对象的类型。比如上述代码第12行，对象e的类型为 Employee，但其实际类型为 Manager\n成员变量的访问\r对于成员变量，编译期间会查看对象类型的成员变量是否存在或者能否访问；我们知道对象的存储空间，连续存放着父类与自己的成员变量，因此运行期间虚拟机会直接去实际类型的空间里直接寻找属于该对象类型的指定变量。\n强制类型转换\r当使用多态时，在编译期间会依据对象的类型判断调用是否合法，那么当我们要使用子类独有的方法或者变量时，如何才能访问成功呢。对于基本数据类型来说，可以使用强制类型转换将一个范围较大的类型转换为另一个范围较小类型。对于对象来说，其实也可以而且方法相同。同样以上述代码为例子：\n1 2 3 4 5 6 7 8 //省略类和其他方法 public void main(String[] args){ Employee e = new Manager(...); e.raiseSalary(...); //不会报错，成功执行 // e.setBonus(...); //报错了 Manager m = (Manager)e; m.setBonus(...) //太对了哥 } 但对于一个对象来说，若转换的类型不对，那么将会产生 ClassCastException 对象转换的编译错误，那么如何保证这个错误不会发生了，我们可以使用 instanceof 操作符，这个操作符顾名思义判断某个对象是否是某个类的实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //省略类和其他方法 public void main(String[] args){ Employee e = new Manager(...); e.raiseSalary(...); //不会报错，成功执行 // e.setBonus(...); //报错了 //这里判断对象e是否是Manager的实例 //如果是则执行代码，否则就跳过，避免了错误的产生 if(e instanceof Manager){ Manager m = (Manager)e; m.setBonus(...) //太对了哥 } //或者如果你使用的是JDK 17，你可以使用下面的语法 //当e雀氏是Manager得实例时，将会自动强转e赋值给m，替换了如上9行的代码 //其实没必要让Manager出现三次对吧 if(e instanceof Manager m){ m.setBonus(...); } } ","date":"2025-07-25T17:46:46+08:00","permalink":"http://localhost:1313/post/2025/07/%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%BB%86%E8%8A%82/","title":"继承"},{"content":"字符\rJava使用 char 类型来表示一个字符。在讨论这个类型前，我们先来说说 Unicode 字符集。\n在1991年 Unicode1.0 发布了，最初的想法是使用 2B = 16bit 来表示最多65536个字符，而当时仅占用65536个代码值中不到一半的部分。因此Java在设计之初决定采用 Unicode 编码字符集来表示字符，采用 UTF-16 字符集编码来编码字符。然而遗憾的是，经过一段时间后，不可避免的事情发生了。Unicode 字符超过了65536个，其主要原因是增加了汉语、日语和韩语中的大量表意文字。现在，16位的 char 类型已经不足以描述所有 Unicode 字符了。\nJava采用码点(Code Point)与代码单元(Code Unit)来解决这个问题。关于码点和代码单元的介绍以及字符集编码和编码字符集的区别，请参考这篇文章。这里简单叙述一下：UTF-16 编码以 2B 为一个代码单元，代码单元是字符编码的基本单位。码点是字符在 Unicode 字符集的位置，使用 U+xxxxx 表示。\nchar 类型就是一个代码单元，只能表示基本字符，若要表示例如 😀(U+1F600) 的辅助字符，必须使用一对代码单元来表示，因此只能将字符抽象为字符串来解决这个问题。\n字符串\rJava使用 String 类型来表示一个字符串。使用字符串则能表示字符类型无法表示的辅助字符。在 JDK9 之前 String 类型的底层实现是一个字符类型的数组，我们由此窥探一下 String 类型是如何解决字符类型无法表示辅助字符的困境的。\n前面提到字符类型本身就是一个代码单元，而数组就给了实现一对代码单元的可能。对于辅助字符，在字符串中会变成两个代码单元，比如😀(U+1F600) 将会变为 0xD83D（高代理）和 0xDE00（低代理），存入字符串后，两个代码单元将被放入数组中连着的两个位置中。这样一个辅助字符就能够存储起来了。对于字符类型来说，其本身就是一个代码单元，即可用来表示一个真实的字符，也可以表示辅助字符的其中一个代码单元。\n而在 JDK9 之后，字符类型的数组被换成了字节型的数组，这是对存储拉丁字符的一个优化，对于类似英文字母这样的字符，使用一个字节表示即可，使用两个字节进行存储实在太浪费空间了。\n字符串常量的共享\r字符串类型可以使用 String str = \u0026quot;xxxxx\u0026quot; 这种形式来赋值。对于字符串常量来说，虚拟机首先会在字符串常量池中查找是否有相同的字符串常量，如果没有就将该字符串常量存入字符串常量池，并将地址返回给字符串变量；如果找到了的话，则将找到的字符串的地址返回给字符串变量，该字符串常量不再存入字符串常量池。因此可以将字符串常量理解为一个实实在在的指针(引用)。而对于使用 subString() 或者 + 生成的字符串，将不会进行共享。\n字符串拼接\r在Java中可以使用 + 拼接或者使用 StringBuilder 类提供的例如 append() 方法进行拼接。我们首先来介绍一下加号拼接的底层原理。\n首先对于字符串常量的拼接，Java对其有一定的优化：\n1 2 3 4 // 使用javac编译为class文件后，这段语句将会直接被拼接在一起 String str1 = \u0026#34;a\u0026#34; + \u0026#34;b\u0026#34; + \u0026#34;c\u0026#34;; // String str1 = \u0026#34;abc\u0026#34;; String str2 = \u0026#34;abc\u0026#34; System.out.println(str1 == str2) //true 对于字符串变量的拼接，每次拼接都会生成新的对象：\n1 2 3 4 5 6 7 8 String str = in.next(); //in 为Scanner的对象 String str1 = str + \u0026#34;a\u0026#34; + \u0026#34;b\u0026#34;; String str2 = str1 + \u0026#34;c\u0026#34;; /* 第一行输入一个字符串常量，该字符串常量将被存入字符串常量池 第二行，将会把\u0026#34;a\u0026#34;存入常量池，随后和str进行拼接，拼接前将会生成一个StringBuilder对象，并执行append方法，再转换为字符串；随后再执行一次上述过程与\u0026#34;b\u0026#34;进行拼接。这个过程将会产生两个StringBuilder对象以及两个字符串对象，耗费时间和空间。 第三行与第二行类似。 */ 可见使用加号拼接字符串非常消耗资源和时间，并且使用加号拼接生成的字符串不会共享地址，详情会在下一节介绍。因此对于过多的字符串拼接，最好使用 StringBuilder 进行拼接。\n注意\r以上为 JDK8 以前的拼接机制，JDK8 以后，每次拼接，虚拟机将会预估字符串所需的长度，生成数组进行存放。虽然节省了空间和时间，但预估字符串长度仍需要时间。\nStringBuilder\rStringBuilder 是一个类专门来处理字符串拼接问题。StringBuilder 的常用 API 如下：\n1 2 3 4 5 6 7 public StringBuilder(); //生成StringBuilder对象，将会生成一个空字符串(不是null)，默认容量为16 public StringBuilder(int capacity); //生成StringBuilder对象，将会生成一个空字符串(不是null)，容量为传入的capacity public StringBuilder(String str); //生成StringBuilder对象，将会生成一个str，容量为16 public StringBuilder append(String str); //拼接字符串 public String toString(); //返回存储的字符串对象 public int capacity(); //返回StringBuilder对象的容量 public int length(); //返回已经存储的字符串的长度 注意\r你可以把 StringBuilder 当成一个容器，StringBuilder 的容量代表着其能存储多长的字符串，length 则代表已经存入字符串的长度，两者之差即是还能存储的字符串的长度\ntoString() 的底层原理\r上述内容曾说过，只有字符串常量才会共享地址，对于使用 new 关键字产生的字符串对象会存放在堆里，并不会进行地址共享。而对于 toString() 来说，翻看源码会发现，正是使用了 new 关键字产生的一个字符串对象。所以，使用 StringBuilder 产生的字符串并不会共享地址。至此，我们就可以解答上一节留下的问题，使用加号拼接的字符串，会使用 StringBuilder 进行拼接，最后使用 toString() 转换为字符串，因此，这个拼接后的字符串不会共享地址。\nStringBuilder 的扩容机制\rStringBuilder 的扩容机制，可以简单地概括为三个点：\nStringBuilder 生成后以用户传入的容量(默认16)作为原始容量 当拼接的字符串大于容量后，以2*原始容量+2的方式进行扩容 当拼接的字符串大于2*原始容量+2，则以拼接的字符串后的长度为容量 下面我们来看具体的源码。需要注意的是，StringBuilder 继承自抽象类 AbstractStringBuilder ，类图如下：\nclassDiagram\rdirection LR\rclass AbstractStringBuilder {\r\u0026lt;\u0026lt;abstract\u0026gt;\u0026gt;\r#byte[] value\r#int count\r#AbstractStringBuilder()\r#AbstractStringBuilder(int capacity)\r+append(obj: Object) AbstractStringBuilder\r+append(str: String) AbstractStringBuilder\r+length() int\r+capacity() int\r}\rclass StringBuilder {\r+StringBuilder()\r+StringBuilder(int capacity)\r+StringBuilder(String str)\r+append(obj: Object) StringBuilder\r+append(str: String) StringBuilder\r+reverse() StringBuilder\r+toString() String\r}\rAbstractStringBuilder \u0026lt;|-- StringBuilder : 继承\r注意\r由类图我们可以发现，StringBuilder 存储字符串依旧使用的是字节数组，这和字符串底层实现是一样的。\n进入 StringBuilder 的字符串的 append(String) 方法，源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 /** 该源码版本为JDK 17 */ public StringBuilder append(String str) { super.append(str); // StringBuidler会调用父类的append(String) return this; } //我们进入父类的append(String)方法 public AbstractStringBuilder append(String str) { if (str == null) { return appendNull(); //若字符串为空，则调用appendNull()，这回拼接\u0026#34;null\u0026#34;这个字符串 } int len = str.length(); //首先算出拼接字符串的长度 //扩容的具体方法，count为已经拼接的字符串的长度，count + len 则是拼接后的字符串的长度，ensureCapacityInternal源码如下 ensureCapacityInternal(count + len); putStringAt(count, str); count += len; return this; } /** 方法参数 minimumCapacity 是扩容的最小容量，即拼接后的字符串长度 */ private void ensureCapacityInternal(int minimumCapacity) { // overflow-conscious code //计算出原来的容量，即底层字节数组的长度，coder是对Latin字符和Unicode字符的优化，下面的方法都是如此 //coder = 0，则是Latin字符，每个字符占1个字节，数组的长度即为字符串长度 //coder = 1，则是Unicode字符，每个字符占2个字节，数组长度右移1位，即除以2，才是字符串的长度 int oldCapacity = value.length \u0026gt;\u0026gt; coder; 、 // 如果拼接后的字符串长度大于了原来的容量，则需进行扩容 if (minimumCapacity - oldCapacity \u0026gt; 0) { //使用Arrays.copyOf()方法即可复制一份新的数组出来，该方法常被用来增长数组的长度 //newCapacity(minimumCapacity)则用来计算新的容量，即扩容，newCapacity源码如下 value = Arrays.copyOf(value,newCapacity(minimumCapacity)则用来计算新的容量，即扩容 \u0026lt;\u0026lt; coder); } } /** 方法参数 minCapacity 的含义同上 */ private int newCapacity(int minCapacity) { int oldLength = value.length; // 字节数组的长度 int newLength = minCapacity \u0026lt;\u0026lt; coder; // 拼接后的字符串的长度，这里转换为了字节 int growth = newLength - oldLength; //需要增加的长度 //最终的扩容实现如下行所示newLength的源码如下： //若Latin字符，则 2 \u0026lt;\u0026lt; coder 为 2Byte，即2个字符 //若Unicode字符，则 2 \u0026lt;\u0026lt; coder 为 4Byte，即2个字符 int length = ArraysSupport.newLength(oldLength, growth, oldLength + (2 \u0026lt;\u0026lt; coder)); //这里可以看出，字节数组的长度最大为Integer.MAX_VALUE，大概为21亿 //Latin字符串长度则为Integer.MAX_VALUE //Unicode字符串长度则为Integer.MAX_VALUE / 2 if (length == Integer.MAX_VALUE) { throw new OutOfMemoryError(\u0026#34;Required length exceeds implementation limit\u0026#34;); } return length \u0026gt;\u0026gt; coder; } /** oldLength：原来的容量，单位为字节 minGrowth：最小的增长长度，即容量扩展到刚好容纳拼接后的字符串 prefGrowth：期望增长长度，值为原始长度 + 2 */ public static int newLength(int oldLength, int minGrowth, int prefGrowth) { // preconditions not checked because of inlining // assert oldLength \u0026gt;= 0 // assert minGrowth \u0026gt; 0 //若最小增加长度 \u0026lt; 期望增长长度，则扩容容量为：oldLength + prefGrowth = 2 * oldLength + 2 // 若最小增加长度 \u0026gt; 期望增长长度, 则扩容容量为：oldLength + prefGrowth = 拼接后的字符串长度 int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow if (0 \u0026lt; prefLength \u0026amp;\u0026amp; prefLength \u0026lt;= SOFT_MAX_ARRAY_LENGTH) { return prefLength; } else { // put code cold in a separate method return hugeLength(oldLength, minGrowth); } } ","date":"2025-07-24T13:31:53+08:00","permalink":"http://localhost:1313/post/2025/07/java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%BE%E8%AE%A1/","title":"Java中的字符与字符串设计"},{"content":"编码字符集和字符集编码\r给每一个字符分配一个固定的编号后，所有的字符就有了顺序，形成了编码字符集。比如“汉”可以分配一个固定编号为 0X6C49 而字符集编码决定了如何将一个字符的整数编号对应到一个二进制的整数值。几乎绝大部分的编码方案就简单的将整数编号一比一还原到计算机存储中。但有的编码方案，例如适用于 Unicode 字符集的 UTF-8 编码形 式，就将很大一部分字符的整数编号作了变换后存储在计算机中。以“汉”字为例，“汉”的 Unicode 值为 0x6C49 ，但其编码为 UTF-8 格式后的值为 0xE6B189 注意到变成了三个字节）\nUnicode 字符集\rUnicode 字符集又称万国码，是一种编码字符集，设计之初的目的是用于表示世界上的所有字符。Unicode 采用 16 个二进制位来表示字符，因此能表示 2^16 = 65536 个字符。但 Unicode 字符集规定的编号并不是字符在计算机存储的二进制值。而是以 UTF-8、UTF-16 这样的字符集编码来决定的。\n基本字符与增补字符：Unicode的\u0026quot;基础库\u0026quot;与\u0026quot;扩展包\u0026quot;\rUnicode 字符集就像一座巨大的图书馆，存放着全球所有的文字、符号和表情。为了方便管理和使用，它被划分为两大区域：基本字符（基础款） 和 增补字符（扩展包）。\n📚 基本字符（Basic Multilingual Plane, BMP）\r位置：Unicode 的第一个平面（U+0000 ~ U+FFFF） 特点： 包含了 99% 的日常使用字符，如： 英文（A-Z, a-z） 常用汉字（中、文、字） 数字（0-9）、标点符号（，。！？） 常见符号（@、#、$、%） 每个字符占用 2 字节（16 位），计算机处理效率高 兼容性最好，几乎所有软件和系统都支持 🎁 增补字符（Supplementary Characters）\r位置：Unicode 的辅助平面（U+10000 ~ U+10FFFF） 特点： 存放 超出基本平面容量的扩展内容，如： Emoji 😊🎉🐱‍👤 生僻汉字 𠀀（U+20000）、𪚥（U+2A6A5） 古代文字 𓀀（埃及象形文字）、𐎀（楔形文字） 特殊符号 𝄞（音乐符号）、𝔄（数学花体字母） 每个字符占用 4 字节（UTF-8）或代理对（UTF-16） 需要现代软件和系统支持（部分老旧程序可能无法显示） 🔧 它们如何协作？\r基本字符 负责日常文字的显示，速度快、兼容性强。 增补字符 扩展了 Unicode 的表达能力，让计算机能支持更多文字、符号和表情。 在编程时，处理增补字符（如 Emoji）可能需要特殊方式，比如： Java 中 \u0026quot;😊\u0026quot;.length() === 2（因为用代理对存储） Python 中 len(\u0026quot;😊\u0026quot;) == 1（正确识别为一个字符） 💡 为什么这样设计？\rUnicode 最初设计时，基本字符（BMP） 已经能满足大多数需求。但随着计算机发展，人们需要更多符号（如 Emoji、古文字、专业符号），于是 增补字符 被引入，确保 Unicode 能不断扩展，而不破坏原有兼容性。\n总结：\n基本字符 = 日常使用的标准字符（高效、兼容性强） 增补字符 = 扩展的符号、表情、生僻字（功能丰富，但需要现代支持） 两者结合，才让计算机能显示全球所有的文字和符号！ 🌍✨ 码点和代码单元\r码点（Code Point）：是Unicode字符集中每个字符的唯一编号，范围从U+0000到U+10FFFF。例如：\n\u0026lsquo;A\u0026rsquo; → U+0041 \u0026lsquo;中\u0026rsquo; → U+4E2D \u0026lsquo;😊\u0026rsquo; → U+1F60A 代码单元（Code Unit）：是具体编码方案中表示码位的基本存储单位：\nUTF-8：使用1-4个8位代码单元 UTF-16：使用1-2个16位代码单元 UTF-32：固定使用1个32位代码单元 在UTF-16编码中：\n基本字符（U+0000至U+FFFF）直接使用1个16位代码单元 增补字符（U+10000及以上）使用2个16位代码单元（代理对） 代理对\rUTF-16通过**代理对(Surrogate Pair)**机制，即两个代码单元表示增补字符，分为高代理与低代理：\n代理区划分：\n高代理区：U+D800～U+DBFF（1024个码位），代理对中的第一个 低代理区：U+DC00～U+DFFF（1024个码位），代理对中的第二个 编码规则：\n将码点减去0x10000，得到20位中间值 高10位 + 0xD800 → 高代理 低10位 + 0xDC00 → 低代理 示例解析： 以‘😊’（U+1F60A）为例：\n1 2 3 4 5 6 7 8 9 码点 U+1F60A ↓ 减去基准值 中间值 0x0F60A（0000 1111 0110 0000 1010） ↓ 拆分为高低10位 高10位：0000 1111 01 → 0x03D 低10位：10 0000 1010 → 0x20A ↓ 加上代理基值 高代理：0xD800 + 0x03D = 0xD83D 低代理：0xDC00 + 0x20A = 0xDE0A 重要特性：\n代理区码位（U+D800～U+DFFF）不表示独立字符 单独出现的高/低代理码元是无效的 Unicode平面（Planes）补充说明\rUnicode字符空间被划分为17个平面（Planes），每个平面包含65,536（2^16）个码位。这种划分方式使得Unicode能够系统地组织超过百万个字符。\n平面划分详解\r基本多文种平面（Plane 0，BMP） 范围：U+0000～U+FFFF 特点：包含最常用的字符，如拉丁字母、汉字基础部分、标点符号等 示例：\u0026lsquo;A\u0026rsquo;（U+0041）、\u0026lsquo;中\u0026rsquo;（U+4E2D） 辅助平面（Plane 1-16） 范围：U+10000～U+10FFFF 总容量：16×65,536=1,048,576个码位 采用代理对机制编码 重要辅助平面\r平面编号 名称 范围 主要内容 Plane 1 补充多文种平面（SMP） U+10000～U+1FFFF 历史文字、音乐符号、表情符号等 Plane 2 补充表意文字平面（SIP） U+20000～U+2FFFF 罕见汉字扩展 Plane 14 特殊用途补充平面（SSP） U+E0000～U+EFFFF 标签字符、变体选择符 Plane 15-16 私人使用区（PUA） U+F0000～U+10FFFF 用户自定义字符 ","date":"2025-07-24T13:31:53+08:00","permalink":"http://localhost:1313/post/2025/07/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AE%80%E8%BF%B0/","title":"字符编码简述"}]