[{"content":"什么是继承\r想象一下对于Secretary类和Manager类，两者共同有相同的字段，比如姓名、职位、工资等等，但Manager类除了工资外还可能有奖金等字段。当我们实现两个类的时候，会声明两份同样的字段和方法，这未免显得太冗余了。因此，我们可以把两个类相同的字段和方法提出来放入另外一个类中，两个类只需要声明他们所需要的字段和方法就好了，其余相同的字段我们只需要从另外一个类中拿取下来就好了，这大大减少了代码的冗余。对于拿取，我们其实可以换一个词，那就是继承，这个词很形象，现实中儿子可以继承父亲的财产，儿子就相当于拥有了父亲的东西。在Java 中，儿子我们称之为子类或者派生类，父亲称之为父类、超类或者基类。\n比如我们可以让Secretary类和Manager类继承Employee类，这样Manager类和Secretary类可以直接使用Employee类的字段和方法。\n在 Java 中，使用 extends 关键字进行继承，我们以Manager类和Employee类举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class Employee { private String name; private double salary; private LocalDate hireDay; //省略构造方法和getter、setter方法 public void raiseSalary(double byPercent) { double raise = salary * byPercent / 100; salary += raise; } } public class Manager extends Employee { //Manager自身的奖金字段 private double bonus; //省略构造方法和getter、setter方法 //Manager自身的方法 public void setBonus(double b) { bonus = b; } } public class Test{ public static void main(String[] args){ Manager m = new Manger(....); m.raiseSalary(...); //Manager并没有声明这个方法，但是Manager从Employee中继承下来了，可以直接访问 //..... } } 注意\r注意，上述说明并没有提到继承的方法和字段的修饰符和访问范围，这点将在下方进行说明\n什么时候使用继承\r当类的关系满足\u0026quot;is-a\u0026quot;关系，即类b就是类a的关系，而且可以被抽取相同的字段或者方法出来时，即可使用继承。例如Manager类和Employee类，经理本身就是员工且Manager类和Employee类有相同的字段和方法，因此可以使用继承。\n继承的层次结构\rJava 中只允许类的单个继承，即一个类只能继承另一个类，但允许一个类被多个类继承，从而形成从上往下的层次结构，例如下图所示：\n%%{init: {\u0026#39;themeVariables\u0026#39;: {\u0026#39;primaryColor\u0026#39;: \u0026#39;#fff\u0026#39;}, \u0026#39;themeConfig\u0026#39;: {\u0026#39;nodeTextMargin\u0026#39;: 4}}}%%\rclassDiagram\rclass Employee\rclass Manager\rclass Secretary\rclass Programmer\rclass Executive\rEmployee \u0026lt;|-- Manager\rEmployee \u0026lt;|-- Secretary\rEmployee \u0026lt;|-- Programmer\rManager \u0026lt;|-- Executive\r任何类都能被继承，包括继承于其他类的类。Java 模糊了父类的概念，对于“祖父类”、“组祖父类”等比本类层级更高的类会被统称为父类，直接继承的称为直接父类，间接继承的称为间接父类，因此任何类都能够继承“祖父类”、“组祖父类”等父类的字段和方法。例如上图中的Executive类能够使用Manager类和Employee类的字段和方法。\n注意\r当类被final关键字修饰时，其本身不允许被继承。\n继承会继承什么\r子类并不会继承父类所有的东西，下面我们先给出结论：\n构造函数无法被继承 父类的所有成员变量都可以被继承，包括私有和非私有 父类的虚方法可以被继承 下面我们来对上述结论进行一一解释\n构造函数\r构造函数是最不可能被继承的一个方法。我们可以使用反证法来证明，若构造函数可以被继承，则子类可以使用此构造函数创建对象。这样以来就违反了构造函数的特征——方法名需要与类名相同。因此该命题出错，那么显然只能是条件就出错了。因此，父类的构造函数不能够被继承。\n重要\r构造函数的两大特征：\n没有返回值 方法名需要与类名相同 成员变量\r在介绍之前，有必要先简要介绍一下虚拟机的内存分布：\n栈空间：用于存放执行的方法的空间。\n当方法执行时，会将方法入栈，期间所有的局部变量都会在该空间内分配。 当方法执行完成之后，方法就会出栈，同时方法中声明的局部变量的空间将会被释放。 堆空间：用于存放对象的空间。\n当使用new关键字创建对象时，会在堆空间开辟一个对象的空间，随后对对象的字段进行初始化。并将该空间的地址返回给引用这个对象的变量。 方法区：用于存放字节码文件。\n当第一次使用到某个类时，该类的字节码文件会被加载到该区域中。 JDK8 以后该区域变成了元空间，但我们不去讨论这些，仅仅做一些如上的简要介绍。 经过上面的介绍，我们现在可以对成员变量的继承进行一个总述了：\n当对某一个对象进行创建时，会在堆空间开辟一个区域存放该对象，由于子类可以继承父类的所有成员变量，因此会从类继承的层次结构的顶层开始，依次对类的成员变量进行初始化，直到本类的字段初始化完成，最终形成了一个对象。对于非私有的变量，允许访问，但对于私有的变量，则无法进行访问，尽管其仍被分配了空间。\n重要\r对于没有继承任何类的类，虚拟机最终会让他继承Object类，所有类都派生于Object类，即Object类是所有类的父类。\n虚方法\r我们把没有被final、static、private修饰的方法成为虚方法。只有虚方法才能被继承。\n理解方法调用\r所有类的成员方法并不会存储到堆空间中，而是存放在方法区中，以字节码的形式存储。每个类的字节码文件会存放着该类的虚方法表，该表记录着所有可以被继承的方法，即虚方法。当使用一个类时，其字节码会被加载到方法区中，同时会沿着继承链把其父类的字节码文件加载进方法区中，这个过程会一直到最顶层的Object类。当类被加载后，虚拟机会为该类计算出一份虚方法表，父类的虚方法表会移交给子类，子类会基于父类的虚方法表并添加上自己的虚方法生成一份自己的，并移交给自己的子类。这样，处于继承层次结构底层的类就会有一份包含父类的虚方法以及自己的虚方法的虚方法表。\n动态绑定\r当一个类调用一个虚方法时，虚拟机就会去访问这个类型的方法表，例如第一节中给的例子，第29行中调用的 raiseSalary() 方法，虚拟机准确的找到了调用者的类型为Manager，于是去访问他的虚方法表，Manager类型继承了Employee类型的虚方法表，里面就有 raiseSalary() 方法，因此可以访问。这个过程称为动态绑定\n静态绑定\r对于非虚方法以及构造方法，虚拟机准确的知道该调用哪些方法，会在编译时就准确的绑定了，不会在运行时绑定，这个过程成为静态绑定。\n警告\r长期以来的一个误解，对于一个方法，虚拟机会依次沿着继承链向上寻找这个方法。这个过程其实是错误的，或者是片面的，因为只有构造方法才会沿着继承链向上依次调用构造方法。\n","date":"2025-07-25T17:46:46+08:00","permalink":"http://localhost:1313/post/2025/07/%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%BB%86%E8%8A%82/","title":"继承"},{"content":"字符\rJava使用 char 类型来表示一个字符。在讨论这个类型前，我们先来说说 Unicode 字符集。\n在1991年 Unicode1.0 发布了，最初的想法是使用 2B = 16bit 来表示最多65536个字符，而当时仅占用65536个代码值中不到一半的部分。因此Java在设计之初决定采用 Unicode 编码字符集来表示字符，采用 UTF-16 字符集编码来编码字符。然而遗憾的是，经过一段时间后，不可避免的事情发生了。Unicode 字符超过了65536个，其主要原因是增加了汉语、日语和韩语中的大量表意文字。现在，16位的 char 类型已经不足以描述所有 Unicode 字符了。\nJava采用码点(Code Point)与代码单元(Code Unit)来解决这个问题。关于码点和代码单元的介绍以及字符集编码和编码字符集的区别，请参考这篇文章。这里简单叙述一下：UTF-16 编码以 2B 为一个代码单元，代码单元是字符编码的基本单位。码点是字符在 Unicode 字符集的位置，使用 U+xxxxx 表示。\nchar 类型就是一个代码单元，只能表示基本字符，若要表示例如 😀(U+1F600) 的辅助字符，必须使用一对代码单元来表示，因此只能将字符抽象为字符串来解决这个问题。\n字符串\rJava使用 String 类型来表示一个字符串。使用字符串则能表示字符类型无法表示的辅助字符。在 JDK9 之前 String 类型的底层实现是一个字符类型的数组，我们由此窥探一下 String 类型是如何解决字符类型无法表示辅助字符的困境的。\n前面提到字符类型本身就是一个代码单元，而数组就给了实现一对代码单元的可能。对于辅助字符，在字符串中会变成两个代码单元，比如😀(U+1F600) 将会变为 0xD83D（高代理）和 0xDE00（低代理），存入字符串后，两个代码单元将被放入数组中连着的两个位置中。这样一个辅助字符就能够存储起来了。对于字符类型来说，其本身就是一个代码单元，即可用来表示一个真实的字符，也可以表示辅助字符的其中一个代码单元。\n而在 JDK9 之后，字符类型的数组被换成了字节型的数组，这是对存储拉丁字符的一个优化，对于类似英文字母这样的字符，使用一个字节表示即可，使用两个字节进行存储实在太浪费空间了。\n字符串常量的共享\r字符串类型可以使用 String str = \u0026quot;xxxxx\u0026quot; 这种形式来赋值。对于字符串常量来说，虚拟机首先会在字符串常量池中查找是否有相同的字符串常量，如果没有就将该字符串常量存入字符串常量池，并将地址返回给字符串变量；如果找到了的话，则将找到的字符串的地址返回给字符串变量，该字符串常量不再存入字符串常量池。因此可以将字符串常量理解为一个实实在在的指针(引用)。而对于使用 subString() 或者 + 生成的字符串，将不会进行共享。\n字符串拼接\r在Java中可以使用 + 拼接或者使用 StringBuilder 类提供的例如 append() 方法进行拼接。我们首先来介绍一下加号拼接的底层原理。\n首先对于字符串常量的拼接，Java对其有一定的优化：\n1 2 3 4 // 使用javac编译为class文件后，这段语句将会直接被拼接在一起 String str1 = \u0026#34;a\u0026#34; + \u0026#34;b\u0026#34; + \u0026#34;c\u0026#34;; // String str1 = \u0026#34;abc\u0026#34;; String str2 = \u0026#34;abc\u0026#34; System.out.println(str1 == str2) //true 对于字符串变量的拼接，每次拼接都会生成新的对象：\n1 2 3 4 5 6 7 8 String str = in.next(); //in 为Scanner的对象 String str1 = str + \u0026#34;a\u0026#34; + \u0026#34;b\u0026#34;; String str2 = str1 + \u0026#34;c\u0026#34;; /* 第一行输入一个字符串常量，该字符串常量将被存入字符串常量池 第二行，将会把\u0026#34;a\u0026#34;存入常量池，随后和str进行拼接，拼接前将会生成一个StringBuilder对象，并执行append方法，再转换为字符串；随后再执行一次上述过程与\u0026#34;b\u0026#34;进行拼接。这个过程将会产生两个StringBuilder对象以及两个字符串对象，耗费时间和空间。 第三行与第二行类似。 */ 可见使用加号拼接字符串非常消耗资源和时间，并且使用加号拼接生成的字符串不会共享地址，详情会在下一节介绍。因此对于过多的字符串拼接，最好使用 StringBuilder 进行拼接。\n注意\r以上为 JDK8 以前的拼接机制，JDK8 以后，每次拼接，虚拟机将会预估字符串所需的长度，生成数组进行存放。虽然节省了空间和时间，但预估字符串长度仍需要时间。\nStringBuilder\rStringBuilder 是一个类专门来处理字符串拼接问题。StringBuilder 的常用 API 如下：\n1 2 3 4 5 6 7 public StringBuilder(); //生成StringBuilder对象，将会生成一个空字符串(不是null)，默认容量为16 public StringBuilder(int capacity); //生成StringBuilder对象，将会生成一个空字符串(不是null)，容量为传入的capacity public StringBuilder(String str); //生成StringBuilder对象，将会生成一个str，容量为16 public StringBuilder append(String str); //拼接字符串 public String toString(); //返回存储的字符串对象 public int capacity(); //返回StringBuilder对象的容量 public int length(); //返回已经存储的字符串的长度 注意\r你可以把 StringBuilder 当成一个容器，StringBuilder 的容量代表着其能存储多长的字符串，length 则代表已经存入字符串的长度，两者之差即是还能存储的字符串的长度\ntoString() 的底层原理\r上述内容曾说过，只有字符串常量才会共享地址，对于使用 new 关键字产生的字符串对象会存放在堆里，并不会进行地址共享。而对于 toString() 来说，翻看源码会发现，正是使用了 new 关键字产生的一个字符串对象。所以，使用 StringBuilder 产生的字符串并不会共享地址。至此，我们就可以解答上一节留下的问题，使用加号拼接的字符串，会使用 StringBuilder 进行拼接，最后使用 toString() 转换为字符串，因此，这个拼接后的字符串不会共享地址。\nStringBuilder 的扩容机制\rStringBuilder 的扩容机制，可以简单地概括为三个点：\nStringBuilder 生成后以用户传入的容量(默认16)作为原始容量 当拼接的字符串大于容量后，以2*原始容量+2的方式进行扩容 当拼接的字符串大于2*原始容量+2，则以拼接的字符串后的长度为容量 下面我们来看具体的源码。需要注意的是，StringBuilder 继承自抽象类 AbstractStringBuilder ，类图如下：\nclassDiagram\rdirection LR\rclass AbstractStringBuilder {\r\u0026lt;\u0026lt;abstract\u0026gt;\u0026gt;\r#byte[] value\r#int count\r#AbstractStringBuilder()\r#AbstractStringBuilder(int capacity)\r+append(obj: Object) AbstractStringBuilder\r+append(str: String) AbstractStringBuilder\r+length() int\r+capacity() int\r}\rclass StringBuilder {\r+StringBuilder()\r+StringBuilder(int capacity)\r+StringBuilder(String str)\r+append(obj: Object) StringBuilder\r+append(str: String) StringBuilder\r+reverse() StringBuilder\r+toString() String\r}\rAbstractStringBuilder \u0026lt;|-- StringBuilder : 继承\r注意\r由类图我们可以发现，StringBuilder 存储字符串依旧使用的是字节数组，这和字符串底层实现是一样的。\n进入 StringBuilder 的字符串的 append(String) 方法，源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 /** 该源码版本为JDK 17 */ public StringBuilder append(String str) { super.append(str); // StringBuidler会调用父类的append(String) return this; } //我们进入父类的append(String)方法 public AbstractStringBuilder append(String str) { if (str == null) { return appendNull(); //若字符串为空，则调用appendNull()，这回拼接\u0026#34;null\u0026#34;这个字符串 } int len = str.length(); //首先算出拼接字符串的长度 //扩容的具体方法，count为已经拼接的字符串的长度，count + len 则是拼接后的字符串的长度，ensureCapacityInternal源码如下 ensureCapacityInternal(count + len); putStringAt(count, str); count += len; return this; } /** 方法参数 minimumCapacity 是扩容的最小容量，即拼接后的字符串长度 */ private void ensureCapacityInternal(int minimumCapacity) { // overflow-conscious code //计算出原来的容量，即底层字节数组的长度，coder是对Latin字符和Unicode字符的优化，下面的方法都是如此 //coder = 0，则是Latin字符，每个字符占1个字节，数组的长度即为字符串长度 //coder = 1，则是Unicode字符，每个字符占2个字节，数组长度右移1位，即除以2，才是字符串的长度 int oldCapacity = value.length \u0026gt;\u0026gt; coder; 、 // 如果拼接后的字符串长度大于了原来的容量，则需进行扩容 if (minimumCapacity - oldCapacity \u0026gt; 0) { //使用Arrays.copyOf()方法即可复制一份新的数组出来，该方法常被用来增长数组的长度 //newCapacity(minimumCapacity)则用来计算新的容量，即扩容，newCapacity源码如下 value = Arrays.copyOf(value,newCapacity(minimumCapacity)则用来计算新的容量，即扩容 \u0026lt;\u0026lt; coder); } } /** 方法参数 minCapacity 的含义同上 */ private int newCapacity(int minCapacity) { int oldLength = value.length; // 字节数组的长度 int newLength = minCapacity \u0026lt;\u0026lt; coder; // 拼接后的字符串的长度，这里转换为了字节 int growth = newLength - oldLength; //需要增加的长度 //最终的扩容实现如下行所示newLength的源码如下： //若Latin字符，则 2 \u0026lt;\u0026lt; coder 为 2Byte，即2个字符 //若Unicode字符，则 2 \u0026lt;\u0026lt; coder 为 4Byte，即2个字符 int length = ArraysSupport.newLength(oldLength, growth, oldLength + (2 \u0026lt;\u0026lt; coder)); //这里可以看出，字节数组的长度最大为Integer.MAX_VALUE，大概为21亿 //Latin字符串长度则为Integer.MAX_VALUE //Unicode字符串长度则为Integer.MAX_VALUE / 2 if (length == Integer.MAX_VALUE) { throw new OutOfMemoryError(\u0026#34;Required length exceeds implementation limit\u0026#34;); } return length \u0026gt;\u0026gt; coder; } /** oldLength：原来的容量，单位为字节 minGrowth：最小的增长长度，即容量扩展到刚好容纳拼接后的字符串 prefGrowth：期望增长长度，值为原始长度 + 2 */ public static int newLength(int oldLength, int minGrowth, int prefGrowth) { // preconditions not checked because of inlining // assert oldLength \u0026gt;= 0 // assert minGrowth \u0026gt; 0 //若最小增加长度 \u0026lt; 期望增长长度，则扩容容量为：oldLength + prefGrowth = 2 * oldLength + 2 // 若最小增加长度 \u0026gt; 期望增长长度, 则扩容容量为：oldLength + prefGrowth = 拼接后的字符串长度 int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow if (0 \u0026lt; prefLength \u0026amp;\u0026amp; prefLength \u0026lt;= SOFT_MAX_ARRAY_LENGTH) { return prefLength; } else { // put code cold in a separate method return hugeLength(oldLength, minGrowth); } } ","date":"2025-07-24T13:31:53+08:00","permalink":"http://localhost:1313/post/2025/07/java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%BE%E8%AE%A1/","title":"Java中的字符与字符串设计"},{"content":"编码字符集和字符集编码\r给每一个字符分配一个固定的编号后，所有的字符就有了顺序，形成了编码字符集。比如“汉”可以分配一个固定编号为 0X6C49 而字符集编码决定了如何将一个字符的整数编号对应到一个二进制的整数值。几乎绝大部分的编码方案就简单的将整数编号一比一还原到计算机存储中。但有的编码方案，例如适用于 Unicode 字符集的 UTF-8 编码形 式，就将很大一部分字符的整数编号作了变换后存储在计算机中。以“汉”字为例，“汉”的 Unicode 值为 0x6C49 ，但其编码为 UTF-8 格式后的值为 0xE6B189 注意到变成了三个字节）\nUnicode 字符集\rUnicode 字符集又称万国码，是一种编码字符集，设计之初的目的是用于表示世界上的所有字符。Unicode 采用 16 个二进制位来表示字符，因此能表示 2^16 = 65536 个字符。但 Unicode 字符集规定的编号并不是字符在计算机存储的二进制值。而是以 UTF-8、UTF-16 这样的字符集编码来决定的。\n基本字符与增补字符：Unicode的\u0026quot;基础库\u0026quot;与\u0026quot;扩展包\u0026quot;\rUnicode 字符集就像一座巨大的图书馆，存放着全球所有的文字、符号和表情。为了方便管理和使用，它被划分为两大区域：基本字符（基础款） 和 增补字符（扩展包）。\n📚 基本字符（Basic Multilingual Plane, BMP）\r位置：Unicode 的第一个平面（U+0000 ~ U+FFFF） 特点： 包含了 99% 的日常使用字符，如： 英文（A-Z, a-z） 常用汉字（中、文、字） 数字（0-9）、标点符号（，。！？） 常见符号（@、#、$、%） 每个字符占用 2 字节（16 位），计算机处理效率高 兼容性最好，几乎所有软件和系统都支持 🎁 增补字符（Supplementary Characters）\r位置：Unicode 的辅助平面（U+10000 ~ U+10FFFF） 特点： 存放 超出基本平面容量的扩展内容，如： Emoji 😊🎉🐱‍👤 生僻汉字 𠀀（U+20000）、𪚥（U+2A6A5） 古代文字 𓀀（埃及象形文字）、𐎀（楔形文字） 特殊符号 𝄞（音乐符号）、𝔄（数学花体字母） 每个字符占用 4 字节（UTF-8）或代理对（UTF-16） 需要现代软件和系统支持（部分老旧程序可能无法显示） 🔧 它们如何协作？\r基本字符 负责日常文字的显示，速度快、兼容性强。 增补字符 扩展了 Unicode 的表达能力，让计算机能支持更多文字、符号和表情。 在编程时，处理增补字符（如 Emoji）可能需要特殊方式，比如： Java 中 \u0026quot;😊\u0026quot;.length() === 2（因为用代理对存储） Python 中 len(\u0026quot;😊\u0026quot;) == 1（正确识别为一个字符） 💡 为什么这样设计？\rUnicode 最初设计时，基本字符（BMP） 已经能满足大多数需求。但随着计算机发展，人们需要更多符号（如 Emoji、古文字、专业符号），于是 增补字符 被引入，确保 Unicode 能不断扩展，而不破坏原有兼容性。\n总结：\n基本字符 = 日常使用的标准字符（高效、兼容性强） 增补字符 = 扩展的符号、表情、生僻字（功能丰富，但需要现代支持） 两者结合，才让计算机能显示全球所有的文字和符号！ 🌍✨ 码点和代码单元\r码点（Code Point）：是Unicode字符集中每个字符的唯一编号，范围从U+0000到U+10FFFF。例如：\n\u0026lsquo;A\u0026rsquo; → U+0041 \u0026lsquo;中\u0026rsquo; → U+4E2D \u0026lsquo;😊\u0026rsquo; → U+1F60A 代码单元（Code Unit）：是具体编码方案中表示码位的基本存储单位：\nUTF-8：使用1-4个8位代码单元 UTF-16：使用1-2个16位代码单元 UTF-32：固定使用1个32位代码单元 在UTF-16编码中：\n基本字符（U+0000至U+FFFF）直接使用1个16位代码单元 增补字符（U+10000及以上）使用2个16位代码单元（代理对） 高代理与低代理\rUTF-16通过**代理对(Surrogate Pair)**机制，即两个代码单元表示增补字符：\n代理区划分：\n高代理区：U+D800～U+DBFF（1024个码位） 低代理区：U+DC00～U+DFFF（1024个码位） 编码规则：\n将码点减去0x10000，得到20位中间值 高10位 + 0xD800 → 高代理 低10位 + 0xDC00 → 低代理 示例解析： 以‘😊’（U+1F60A）为例：\n1 2 3 4 5 6 7 8 9 码点 U+1F60A ↓ 减去基准值 中间值 0x0F60A（0000 1111 0110 0000 1010） ↓ 拆分为高低10位 高10位：0000 1111 01 → 0x03D 低10位：10 0000 1010 → 0x20A ↓ 加上代理基值 高代理：0xD800 + 0x03D = 0xD83D 低代理：0xDC00 + 0x20A = 0xDE0A 重要特性：\n代理区码位（U+D800～U+DFFF）不表示独立字符 单独出现的高/低代理码元是无效的 Unicode平面（Planes）补充说明\rUnicode字符空间被划分为17个平面（Planes），每个平面包含65,536（2^16）个码位。这种划分方式使得Unicode能够系统地组织超过百万个字符。\n平面划分详解\r基本多文种平面（Plane 0，BMP） 范围：U+0000～U+FFFF 特点：包含最常用的字符，如拉丁字母、汉字基础部分、标点符号等 示例：\u0026lsquo;A\u0026rsquo;（U+0041）、\u0026lsquo;中\u0026rsquo;（U+4E2D） 辅助平面（Plane 1-16） 范围：U+10000～U+10FFFF 总容量：16×65,536=1,048,576个码位 采用代理对机制编码 重要辅助平面\r平面编号 名称 范围 主要内容 Plane 1 补充多文种平面（SMP） U+10000～U+1FFFF 历史文字、音乐符号、表情符号等 Plane 2 补充表意文字平面（SIP） U+20000～U+2FFFF 罕见汉字扩展 Plane 14 特殊用途补充平面（SSP） U+E0000～U+EFFFF 标签字符、变体选择符 Plane 15-16 私人使用区（PUA） U+F0000～U+10FFFF 用户自定义字符 ","date":"2025-07-24T13:31:53+08:00","permalink":"http://localhost:1313/post/2025/07/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AE%80%E8%BF%B0/","title":"字符编码简述"}]